{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17132492703364281294,"abi":{"parameters":[{"name":"carrier_code","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"flight_number","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"date","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"price","type":{"kind":"field"},"visibility":"private"},{"name":"plane_valid","type":{"kind":"field"},"visibility":"private"},{"name":"insurance_valid","type":{"kind":"field"},"visibility":"private"},{"name":"hash_data","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"signature","type":{"kind":"struct","path":"noir_rsa::bignum::runtime_bignum::RuntimeBigNum","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"params","type":{"kind":"struct","path":"noir_rsa::bignum::params::BigNumParams","fields":[{"name":"has_multiplicative_inverse","type":{"kind":"boolean"}},{"name":"modulus","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"double_modulus","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"redc_param","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}}]}}]},"visibility":"public"},{"name":"public_key","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"\nuse sha256;\nuse noir_rsa::rsa;\nuse noir_rsa::types::RBN2048;\n\n\n// verify_flight\nfn main(\n    carrier_code: [Field; 2],     // e.g. 'A' = 65, 'F' = 70\n    flight_number: [Field; 4],    // '0','2','6','4' as ASCII at max, can be other char as 4DF\n    date: [Field; 3],             // [2025, 4, 29]\n    price: Field,                 // 25\n    plane_valid: Field,           // 1 for true\n    insurance_valid: Field,       // 1 for true\n    // Public \n    hash_data: pub [u8; 32], \n    signature: pub RBN2048,           // The signature from the certificate\n    public_key: pub Field           // The public key to verify the signature\n) {\n\n    // FIXME: optimization send only the hash??\n    // Issue could be on the date? What if I generate locally multiple issue and wait until we get the right one?\n\n    // Field::from(32) => encode the ASCII \" \"\n\n    // Verify the flag are correct\n    assert_eq(plane_valid, 1);\n    assert_eq(insurance_valid, 1);\n    assert((price as u8) > 0);\n    assert((price as u8) < 200);\n\n    assert((date[0] as u8) < 20);\n    assert((date[1] as u8) < 20);\n\n    // FIXME: \n\n    // Concatenate fields into a list for hashing\n    let mut combined_data: [u8; 12] = [\n        carrier_code[0] as u8,          // 'A' -> 65\n        carrier_code[1] as u8,          // 'F' -> 70\n        Field::from(32) as u8,          // Placeholder for flight_number[0]\n        Field::from(32) as u8,          // Placeholder for flight_number[1]\n        Field::from(32) as u8,          // Placeholder for flight_number[2]\n        Field::from(32) as u8,          // Placeholder for flight_number[3]\n        date[0] as u8,                  // 2025  FIXME:\n        date[1] as u8,                  // 4\n        date[2] as u8,                  // 29\n        price as u8,                    // 25\n        plane_valid as u8,              // 1\n        insurance_valid as u8           // 1\n    ];\n\n\n    // Flight number can be variable put up to 4 character\n    for i in 0..flight_number.len() {  \n        combined_data[2+i] = flight_number[i] as u8;\n    }\n\n    // Compute the hash of the combined data using Poseidon\n    let hashed_data: [u8; 32] = sha256::digest(combined_data).into();\n\n    // Check the input hash\n    assert_eq(hash_data, hashed_data);\n\n    assert(rsa::verify_sha256_pkcs1v15(\n        hashed_data, \n        signature, \n        65537  // Mostly used parameter (fixed)\n    ));\n\n}\n\n// #[test]\n// fn test_verify_flight() {\n//     verify_flight(\n//         [65, 70],  // AF\n//         [0,2,6,4],  // FIXME: Need to conver to ASCII\n//         [2025, 4, 29],             // [2025, 4, 29]\n//         25,                 // 25\n//         1,           // 1 for true\n//         1,       // 1 for true\n//         // Public \n//         hash_data: [\n//             110,\n//             155,\n//             187,\n//             195,\n//             71,\n//             192,\n//             157,\n//             198,\n//             199,\n//             248,\n//             55,\n//             78,\n//             248,\n//             223,\n//             153,\n//             161,\n//             224,\n//             139,\n//             91,\n//             64,\n//             124,\n//             33,\n//             205,\n//             164,\n//             237,\n//             52,\n//             124,\n//             8,\n//             118,\n//             0,\n//             211,\n//             113\n//         ], \n//         signature: \"h9G/TIe+otw6xGeqP3ZFhnxRk0bKPnQp6m08/jnrr04GpF+QYVc8N9anNA29bosYtQkCA6kW5CiehoCXTrafIUCgNZ8oGoTXq1Gk1CoTSHNSBxJbhBXqX30HnwuNcXCDs93NxcaDCi5bEntb7R0MFc35erwqi2FJBnSWDaQvLjtCV/8WhKMztmwlBMCFbB1NlTWxzLppYeaIpXF6zCb8+RjMna6HC9YYNf7LIUfUbMEnvwp7ZmTJgtm6xoCxo/GhcEJb/9RF5J7w9HK9ymbB+BNOYxv3D+UYq7PNZrj3ua/owELQTWFL3PNcKVyaMKBTNF2zq6mUZuAwJ4MwHeSZQA==\",\n//         public_key: \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNz2t69UIGA+WUCvOuFSI94Ib1ykRkdvhMuJesC7PZUYcWJNgEfvQ7ACnSZQwVEkuYlQugoEyWWb6cI/VGq5ZXYbTTDp+7R9kjyZQ0vYt4k/TOr/HGosAZXce6LdwMRzwPRmGPfoF9fbLWSlwu/gzfJIDaTqob7+hwpowPQYTuvVoFJyB9kS7jKOCYByQfyoiFuD8GrTSGKXVbiWAA6gCgHUu4s9vOgTWhcVF4F62DjODdhlvJTH6+xgUE6XIa2ZTtjEr7gp87QxmhIy9/F3ZY42mwaXvNZ3HdmZuE38toKTx7cVGbICR+gx1N+AMET2K8Vcs5fzeGeOcjHP7z1kWwIDAQAB\"\n//     );\n\n// }\n","path":"/home/rere/Projects/noir-flight-insurance/circuits/flight_booking/src/main.nr"},"114":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"},"150":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"151":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"153":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"154":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"155":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"158":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"165":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"168":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/rere/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","directive_integer_quotient","directive_invert","directive_to_radix"]}