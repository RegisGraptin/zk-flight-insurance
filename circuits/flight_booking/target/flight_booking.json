{"noir_version":"1.0.0-beta.4+3a5a15ac70e52b4e67edc69e8aa5ad7780523f87","hash":"12424029411558936119","abi":{"parameters":[{"name":"carrier_code","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"flight_number","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"date","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"price","type":{"kind":"field"},"visibility":"private"},{"name":"plane_valid","type":{"kind":"field"},"visibility":"private"},{"name":"insurance_valid","type":{"kind":"field"},"visibility":"private"},{"name":"hash_data","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"struct","path":"noir_rsa::bignum::runtime_bignum::RuntimeBigNum","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"params","type":{"kind":"struct","path":"noir_rsa::bignum::params::BigNumParams","fields":[{"name":"has_multiplicative_inverse","type":{"kind":"boolean"}},{"name":"modulus","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"double_modulus","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"redc_param","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}}}]}}]},"visibility":"private"},{"name":"public_key","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"\nuse sha256;\nuse noir_rsa::rsa;\nuse noir_rsa::types::RBN2048;\n\n\n// verify_flight\nfn main(\n    carrier_code: [Field; 2],     // e.g. 'A' = 65, 'F' = 70\n    flight_number: [Field; 4],    // '0','2','6','4' as ASCII at max, can be other char as 4DF\n    date: [Field; 3],             // [2025, 4, 29]\n    price: Field,                 // 25\n    plane_valid: Field,           // 1 for true\n    insurance_valid: Field,       // 1 for true\n    // Public \n    hash_data: [u8; 32], \n    signature: RBN2048,           // The signature from the certificate\n    public_key: Field           // The public key to verify the signature\n) {\n\n    // FIXME: optimization send only the hash??\n    // Issue could be on the date? What if I generate locally multiple issue and wait until we get the right one?\n\n    // Field::from(32) => encode the ASCII \" \"\n\n    // Verify the flag are correct\n    assert_eq(plane_valid, 1);\n    assert_eq(insurance_valid, 1);\n    assert((price as u8) > 0);\n    assert((price as u8) < 200);\n\n    // Concatenate fields into a list for hashing\n    let mut combined_data: [u8; 12] = [\n        carrier_code[0] as u8,          // 'A' -> 65\n        carrier_code[1] as u8,          // 'F' -> 70\n        Field::from(32) as u8,          // Placeholder for flight_number[0]\n        Field::from(32) as u8,          // Placeholder for flight_number[1]\n        Field::from(32) as u8,          // Placeholder for flight_number[2]\n        Field::from(32) as u8,          // Placeholder for flight_number[3]\n        date[0] as u8,                  // 2025  FIXME:\n        date[1] as u8,                  // 4\n        date[2] as u8,                  // 29\n        price as u8,                    // 25\n        plane_valid as u8,              // 1\n        insurance_valid as u8           // 1\n    ];\n\n\n    // Flight number can be variable put up to 4 character\n    for i in 0..flight_number.len() {  \n        combined_data[2+i] = flight_number[i] as u8;\n    }\n\n    // Compute the hash of the combined data using Poseidon\n    let hashed_data: [u8; 32] = sha256::digest(combined_data).into();\n\n    // Check the input hash\n    assert_eq(hash_data, hashed_data);\n\n    assert(rsa::verify_sha256_pkcs1v15(\n        hashed_data, \n        signature, \n        65537  // Mostly used parameter (fixed)\n    ));\n\n}\n\n// #[test]\n// fn test_verify_flight() {\n//     verify_flight(\n//         [65, 70],  // AF\n//         [0,2,6,4],  // FIXME: Need to conver to ASCII\n//         [2025, 4, 29],             // [2025, 4, 29]\n//         25,                 // 25\n//         1,           // 1 for true\n//         1,       // 1 for true\n//         // Public \n//         hash_data: [\n//             110,\n//             155,\n//             187,\n//             195,\n//             71,\n//             192,\n//             157,\n//             198,\n//             199,\n//             248,\n//             55,\n//             78,\n//             248,\n//             223,\n//             153,\n//             161,\n//             224,\n//             139,\n//             91,\n//             64,\n//             124,\n//             33,\n//             205,\n//             164,\n//             237,\n//             52,\n//             124,\n//             8,\n//             118,\n//             0,\n//             211,\n//             113\n//         ], \n//         signature: \"h9G/TIe+otw6xGeqP3ZFhnxRk0bKPnQp6m08/jnrr04GpF+QYVc8N9anNA29bosYtQkCA6kW5CiehoCXTrafIUCgNZ8oGoTXq1Gk1CoTSHNSBxJbhBXqX30HnwuNcXCDs93NxcaDCi5bEntb7R0MFc35erwqi2FJBnSWDaQvLjtCV/8WhKMztmwlBMCFbB1NlTWxzLppYeaIpXF6zCb8+RjMna6HC9YYNf7LIUfUbMEnvwp7ZmTJgtm6xoCxo/GhcEJb/9RF5J7w9HK9ymbB+BNOYxv3D+UYq7PNZrj3ua/owELQTWFL3PNcKVyaMKBTNF2zq6mUZuAwJ4MwHeSZQA==\",\n//         public_key: \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNz2t69UIGA+WUCvOuFSI94Ib1ykRkdvhMuJesC7PZUYcWJNgEfvQ7ACnSZQwVEkuYlQugoEyWWb6cI/VGq5ZXYbTTDp+7R9kjyZQ0vYt4k/TOr/HGosAZXce6LdwMRzwPRmGPfoF9fbLWSlwu/gzfJIDaTqob7+hwpowPQYTuvVoFJyB9kS7jKOCYByQfyoiFuD8GrTSGKXVbiWAA6gCgHUu4s9vOgTWhcVF4F62DjODdhlvJTH6+xgUE6XIa2ZTtjEr7gp87QxmhIy9/F3ZY42mwaXvNZ3HdmZuE38toKTx7cVGbICR+gx1N+AMET2K8Vcs5fzeGeOcjHP7z1kWwIDAQAB\"\n//     );\n\n// }\n","path":"/home/rere/Projects/noir-flight-insurance/circuits/flight_booking/src/main.nr"},"111":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"},"147":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"148":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"150":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"151":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"152":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"155":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"162":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/rere/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"165":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/rere/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","directive_integer_quotient","directive_invert","directive_to_radix"]}